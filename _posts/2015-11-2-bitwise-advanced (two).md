---

layout: post
title: 'Gray码问题 Bitwise Operation 位操作 ' 
date: '2015-11-2'
header-img: "img/post-bg-web.jpg"
tags:
     - bit
     - 位操作
author: 'Bill Quan'

---
## Gray码

n=2的Gray（格雷码）遍历顺序如下：

	00
	01
	11
	10

n=3时一共有8种状态，其中前面4个把n=2的遍历顺序照搬下来，然后把它们对称翻折下去并在最前面加上1作为后面4个状态：

	000
	001
	011
	010  ↑
	——–
	110  ↓
	111
	101
	100

用这种方法得到的遍历顺序显然符合要求。首先，上面8个状态恰好是n=3时的所有8种组合，因为它们是在n=2的全部四种组合的基础上考虑选不选第3个元素所得到的。然后我们看到，后面一半的状态应该和前面一半一样满足“相邻状态间仅一位不同”的限制，而“镜面”处则是最前面那一位数不同。再次翻折三阶遍历顺序，我们就得到了刚才的问题的答案：

	0000
	0001
	0011
	0010
	0110
	0111
	0101
	0100
	1100
	1101
	1111
	1110
	1010
	1011
	1001
	1000

这种遍历顺序作为一种编码方式存在，叫做Gray码（写个中文让蜘蛛来抓：格雷码）。它的应用范围很广。比如，n阶的Gray码相当于在n维立方体上的Hamilton回路，因为沿着立方体上的边走一步，n维坐标中只会有一个值改变。再比如，Gray码和Hanoi塔问题等价。Gray码改变的是第几个数，Hanoi塔就该移动哪个盘子。比如，3阶的Gray码每次改变的元素所在位置依次为1-2-1-3-1-2-1，这正好是3阶Hanoi塔每次移动盘子编号。如果我们可以快速求出Gray码的第n个数是多少，我们就可以输出任意步数后Hanoi塔的移动步骤。

**Gray码的第n个数（从0算起）是n xor (n shr 1)**

下面我们把二进制数和Gray码都写在下面，可以看到左边的数异或自身右移的结果就等于右边的数。

	 二进制数    Gray码
	   000       000
	   001       001
	   010       011
	   011       010
	   100       110
	   101       111
	   110       101
	   111       100

从二进制数的角度看，“镜像”位置上的数即是对原数进行not运算后的结果。比如，第3个数010和倒数第3个数101的每一位都正好相反。假设这两个数分别为x和y，那么x xor (x shr 1)和y xor (y shr 1)的结果只有一点不同：后者的首位是1，前者的首位是0。而这正好是Gray码的生成方法。这就说明了，Gray码的第n个数确实是n xor (n shr 1)。


##二维意义上的Gray码

把0到2^(n+m)-1的数写成2^n * 2^m的矩阵，使得位置相邻两数的二进制表示只有一位之差。

答案很简单，所有数都是由m位的Gray码和n位Gray码拼接而成，需要用左移操作和or运算完成。完整的代码如下：

	var
	   x,y,m,n,u:longint;
	begin
	   readln(m,n);
	   for x:=0 to 1 shl m-1 do begin
	      u:=(x xor (x shr 1)) shl n; //输出数的左边是一个m位的Gray码
	      for y:=0 to 1 shl n-1 do
	         write(u or (y xor (y shr 1)),' '); //并上一个n位Gray码
	      writeln;
	   end;
	end.


<br>

> 如有任何知识产权、版权问题或理论错误，还请指正。
>
> 转载请注明原作者及以上信息。
