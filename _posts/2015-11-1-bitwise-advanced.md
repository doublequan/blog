---

layout: post
title: 'Advanced Bitwise Operation 位操作进阶'
date: '2015-11-1'
header-img: "img/post-bg-web.jpg"
tags:
     - bit
     - 位操作
     - 进阶
author: 'Bill Quan'

---

### 二进制中的1有奇数个还是偶数个

我们可以用下面的代码来计算一个32位整数的二进制中1的个数的奇偶性，当输入数据的二进制表示里有偶数个数字1时程序输出0，有奇数个则输出1。例如，1314520的二进制101000000111011011000中有9个1，则x=1314520时程序输出1。

	var
	   i,x,c:longint;
	begin
	   readln(x);
	   c:=0;
	   for i:=1 to 32 do
	   begin
	      c:=c + x and 1;
	      x:=x shr 1;
	   end;
	   writeln( c and 1 );
	end.

但这样的效率并不高，位运算的神奇之处还没有体现出来。
同样是判断二进制中1的个数的奇偶性，下面这段代码就强了。你能看出这个代码的原理吗？

var
   x:longint;
begin
   readln(x);
   x:=x xor (x shr 1);
   x:=x xor (x shr 2);
   x:=x xor (x shr 4);
   x:=x xor (x shr 8);
   x:=x xor (x shr 16);
   writeln(x and 1);
end.

为了说明上面这段代码的原理，我们还是拿1314520出来说事。1314520的二进制为101000000111011011000，第一次异或操作的结果如下：

          00000000000101000000111011011000
	XOR    0000000000010100000011101101100
	  —————————————————————————————————————
          00000000000111100000100110110100


得到的结果是一个新的二进制数，其中右起第i位上的数表示原数中第i和i+1位上有奇数个1还是偶数个1。比如，最右边那个0表示原数末两位有偶数个1，右起第3位上的1就表示原数的这个位置和前一个位置中有奇数个1。对这个数进行第二次异或的结果如下：


	    00000000000111100000100110110100
	XOR   000000000001111000001001101101
	—————————————
	    00000000000110011000101111011001

结果里的每个1表示原数的该位置及其前面三个位置中共有奇数个1，每个0就表示原数对应的四个位置上共偶数个1。一直做到第五次异或结束后，得到的二进制数的最末位就表示整个32位数里有多少个1，这就是我们最终想要的答案。


### 计算二进制中的1的个数

同样假设x是一个32位整数。经过下面五次赋值后，x的值就是原数的二进制表示中数字1的个数。比如，初始时x为1314520，那么最后x就变成了9，它表示1314520的二进制中有9个1。

	x := (x and $55555555) + ((x shr 1) and $55555555);
	x := (x and $33333333) + ((x shr 2) and $33333333);
	x := (x and $0F0F0F0F) + ((x shr 4) and $0F0F0F0F);
	x := (x and $00FF00FF) + ((x shr 8) and $00FF00FF);
	x := (x and $0000FFFF) + ((x shr 16) and $0000FFFF);

为了便于解说，我们下面仅说明这个程序是如何对一个8位整数进行处理的。我们拿数字211为例。211的二进制为11010011。
	
	
	| 1 | 1 | 0 | 1 | 0 | 0 | 1 | 1 |   <—原数
	
	|  1 0  |  0 1  |  0 0  |  1 0  |   <—第一次运算后
	
	|    0 0 1 1    |    0 0 1 0    |   <—第二次运算后
	
	|        0 0 0 0 0 1 0 1        |   <—第三次运算后，得数为5
	

整个程序是一个分治的思想。第一次我们把每相邻的两位加起来，得到每两位里1的个数，比如前两位10就表示原数的前两位有2个1。第二次我们继续两两相加，10+01=11，00+10=10，得到的结果是00110010，它表示原数前4位有3个1，末4位有2个1。最后一次我们把0011和0010加起来，得到的就是整个二进制中1的个数。程序中巧妙地使用取位和右移，比如第二行中$33333333的二进制为00110011001100….，用它和x做and运算就相当于以2为单位间隔取数。shr的作用就是让加法运算的相同数位对齐。


### 二分查找32位整数的前导0个数

程序思想是二分查找

	int nlz(unsigned x)
	{
	   int n;
	
	   if (x == 0) return(32);
	   n = 1;
	   if ((x >> 16) == 0) {n = n +16; x = x <<16;}
	   if ((x >> 24) == 0) {n = n + 8; x = x << 8;}
	   if ((x >> 28) == 0) {n = n + 4; x = x << 4;}
	   if ((x >> 30) == 0) {n = n + 2; x = x << 2;}
	   n = n - (x >> 31);
	   return n;
	}

### 只用位运算来取绝对值

这是一个非常有趣的问题。

答案：假设x为32位整数，则x xor (not (x shr 31) + 1) + x shr 31的结果是x的绝对值
x shr 31是二进制的最高位，它用来表示x的符号。如果它为0（x为正），则not (x shr 31) + 1等于$00000000，异或任何数结果都不变；如果最高位为1（x为负），则not (x shr 31) + 1等于$FFFFFFFF，x异或它相当于所有数位取反，异或完后再加一。


### 高低位交换

给出一个小于2^32的正整数。这个数可以用一个32位的二进制数表示（不足32位用0补足）。我们称这个二进制数的前16位为“高位”，后16位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。
例如，数1314520用二进制表示为0000 0000 0001 0100 0000 1110 1101 1000（添加了11个前导0补足为32位），其中前16位为高位，即0000 0000 0001 0100；后16位为低位，即0000 1110 1101 1000。将它的高低位进行交换，我们得到了一个新的二进制数0000 1110 1101 1000 0000 0000 0001 0100。它即是十进制的249036820。

    
	var
	   n:dword;
	begin
	   readln( n );
	   writeln( (n shr 16) or (n  shl 16) );
	end.

 


<br>

> 如有任何知识产权、版权问题或理论错误，还请指正。
>
> 转载请注明原作者及以上信息。
